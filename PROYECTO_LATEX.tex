\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{placeins}


% Configuraci√≥n del formato de la p√°gina
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
}

% Configuraci√≥n del paquete listings para el c√≥digo
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Definici√≥n del t√≠tulo y el autor
\title{\vspace{-1.5cm}\textbf{\huge Proyecto √Ålgebra Lineal}}
\author{} % Se deja vac√≠o para que no aparezca autor si no es necesario
\date{}

\begin{document}

\maketitle
\thispagestyle{empty} % Oculta el n√∫mero de p√°gina en la primera p√°gina

\begin{center}
    \href{https://github.com/jgarnigar/Proyecto-Algebra-Lineal/tree/master}{\textbf{GitHub Repository - jgarnigar}}
\end{center}

\vspace{0.5cm}

% Comienzo del contenido del documento
% La siguiente parte (II. Contenido del Documento) va aqu√≠.

\section*{\centering \Large \textbf{Descripci√≥n}}
\label{sec:descripcion}
\begin{itemize}
    \item Los datos fueron encriptados multiplicando una matriz $6 \times 6$ por una matriz $6 \times 1$. El resultado es una matriz $6 \times 1$ con los datos encriptados. Estos datos nuevos ocultan una imagen. La nueva matriz $6 \times 1$ nos da los valores $(x,y)$.
    \item Para desencriptar estos datos, obtendremos la matriz inversa de la matriz $6 \times 6$ y multiplicaremos por la $6 \times 1$ con los datos encriptados.
    \item Finalmente usaremos \textbf{Matplotlib} con el fin de visualizar los datos desencriptados.
\end{itemize}

\hrule

\section*{\centering \Large \textbf{√çndice}}
\label{sec:indice}
\begin{enumerate}
    \item \hyperref[sec:descripcion]{Descripci√≥n}
    \item \hyperref[sec:instalacion]{Instalaci√≥n y requisitos}
    \item \hyperref[sec:objetivo]{Objetivo}
    \item \hyperref[sec:estructura]{Estructura}
    \item \hyperref[sec:operaciones]{Operaciones matem√°ticas}
    \item \hyperref[sec:metodos]{M√©todos de Numpy}
    \item \hyperref[sec:datos]{Datos}
    \item \hyperref[sec:ecuaciones]{Ecuaciones}
    \begin{enumerate}
        \item \hyperref[sub:ecuacion1]{Primera ecuaci√≥n}
        \item \hyperref[sub:ecuacion2]{Segunda ecuaci√≥n}
        \item \hyperref[sub:ecuacion3]{Tercera ecuaci√≥n}
        \item \hyperref[sub:ecuacion4]{Cuarta ecuaci√≥n}
        \item \hyperref[sub:resultado]{Resultado de las ecuaciones}
    \end{enumerate}
    \item \hyperref[sec:clases]{Clases}
    \begin{enumerate}
        \item \hyperref[sub:librerias]{Librer√≠as}
        \item \hyperref[sub:cifrado]{Cifrado()}
        \item \hyperref[sub:crear-array]{Crear\_Array()}
        \item \hyperref[sub:ecuacion]{Ecuacion()}
        \item \hyperref[sub:desempaquetar-array]{Desempaquetar\_Array()}
        \item \hyperref[sub:rotacion]{Rotacion()}
        \item \hyperref[sub:traslacion]{Traslacion()}
        \item \hyperref[sub:guardar-datos]{GuardarDatos()}
        \item \hyperref[sub:app]{App()}
        \item \hyperref[sub:graficar]{Graficar()}
    \end{enumerate}
    \item \hyperref[sec:instancias]{Instancias}
    \item \hyperref[sec:comprobacion]{Comprobaci√≥n de datos}
    \begin{enumerate}
        \item \hyperref[sub:matriz-inversa]{Matriz inversa}
        \item \hyperref[sub:desencriptar-datos-comp]{Desencriptar datos}
        \item \hyperref[sub:rotacion-datos-comp]{Rotaci√≥n}
        \item \hyperref[sub:traslacion-comp]{Traslaci√≥n}
    \end{enumerate}
    \item \hyperref[sec:desencriptar]{Desencriptar datos}
    \item \hyperref[sec:graficas]{Gr√°ficas - Datos Resueltos!}
    \begin{enumerate}
        \item \hyperref[sub:grafico-desencriptado]{Gr√°fico desencriptado}
        \item \hyperref[sub:grafico-rotacion]{Gr√°fico Matriz Rotaci√≥n}
        \item \hyperref[sub:grafico-rotacion-traslado]{Gr√°fico Matriz Rotaci√≥n y Traslado}
    \end{enumerate}
    \item \hyperref[sec:guardar-datos]{Guardar Datos}
    \item \hyperref[sec:conclusiones]{Conclusiones} % Nueva secci√≥n
    \item \hyperref[sec:autor]{Autor}
    \item \hyperref[sec:anexo-a]{Anexo A: Estructura del Proyecto} % Nuevo Anexo
    \item \hyperref[sec:anexo-b]{Anexo B: Tecnolog√≠as Empleadas} % Nuevo Anexo
    \item \hyperref[sec:anexo-c]{Anexo C: Fundamentos Te√≥ricos}
\end{enumerate}

\hrule

\section*{\centering \Large \textbf{Instalaci√≥n y requisitos}}
\label{sec:instalacion}
Utilizaremos \textbf{Python} 3.10 o superior, \textbf{Numpy} y \textbf{Matplotlib}. Para asegurarnos que todo funcione, por favor cree un entorno virtual.

\subsection*{Instalar Python 3.10 o superior}
\href{https://www.python.org/downloads/}{Descargar Python}

\subsection*{Clone el repositorio:}
\begin{lstlisting}[language=bash]
git clone https://github.com/jgarnigar/Proyecto-Algebra-Lineal.git
\end{lstlisting}

\subsection*{Crear el entorno virtual}
\begin{lstlisting}[language=bash]
python -m venv venv
source venv/bin/activate      # Para Linux/Mac
venv\Scripts\activate         # Para Windows
\end{lstlisting}

\subsection*{Instale los requerimientos}
\begin{lstlisting}[language=bash]
pip install -r requirements.txt
\end{lstlisting}

\subsection*{Ejecuci√≥n del programa}
Una vez tengamos el repositorio clonado y todos los requisitos instalados, ejecute este c√≥digo desde la carpeta principal:
\begin{lstlisting}[language=bash]
python main.py
\end{lstlisting}
\textbf{\color{red}Nota:} aseg√∫rese de ejecutar este comando desde la carpeta ra√≠z del proyecto.

\hrule

\section*{\centering \Large \textbf{Objetivo}}
\label{sec:objetivo}
\begin{itemize}
    \item El objetivo es crear un algoritmo a trav√©s de \textbf{Python} y \textbf{Numpy} para poder desencriptar estos datos de forma automatizada y por √∫ltimo mostrar estos datos con \textbf{Matplotlib}.
\end{itemize}

\hrule

\section*{\centering \Large \textbf{Estructura}}
\label{sec:estructura}
\textbf{Proyecto √Ålgebra Lineal}
\begin{verbatim}
‚î£ üìÅ datos/           ‚Üí Datos encriptados y desencriptados
‚î£ üìÅ funciones/        ‚Üí Funciones l√≥gicas
‚î£ üìÑ main.py         ‚Üí Archivo principal de ejecuci√≥n
‚î£ üìÑ requirements.txt
‚îó üìÑ README.md
\end{verbatim}

\hrule

\section*{\centering \Large \textbf{Operaciones matem√°ticas}}
\label{sec:operaciones}
Estos son los temas utilizados para resolver el proyecto.
\begin{itemize}
    \item Multiplicaci√≥n de matrices.
    \item Matrices inversas.
    \item Determinantes.
    \item Sistema de ecuaciones.
    \item Producto escalar.
    \item Producto vectorial.
\end{itemize}

\hrule

\section*{\centering \Large \textbf{M√©todos de Numpy.}}
\label{sec:metodos}
Explicaremos brevemente los m√©todos utilizados en \textbf{Numpy} para poder trabajar con nuestas clases.
\begin{itemize}
    \item \textbf{np.linalg.inv()} $\Rightarrow$ Inversa de una matriz.
    \item \textbf{matriz\_a @ matriz\_b} $\Rightarrow$ Multiplicaci√≥n de matrices.
    \item \textbf{np.array()} $\Rightarrow$ Creaci√≥n de arrays.
    \item \textbf{np.linalg.solve(primer\_termino, segundo\_termino)} $\Rightarrow$ Resoluci√≥n de sistema de ecuaciones.
    \item \textbf{np.ravel()} $\Rightarrow$ Convierte un array multidimensional en uno unidimensional.
    \item \textbf{np.deg2rad()} $\Rightarrow$ Convierte un √°ngulo en grados a radianes.
    \item \textbf{np.cos()} $\Rightarrow$ Funci√≥n Coseno.
    \item \textbf{np.sen()} $\Rightarrow$ Funci√≥n Seno.
    \item \textbf{np.reshape()} $\Rightarrow$ Funci√≥n para transformar la dimensi√≥n de arrays. Ejemplo, pasar de $1 \times 6$ a $6 \times 1$.
    \begin{itemize}
        \item Si el array es un $1 \times 6$, usamos \textbf{np.reshape(-1, 1)}: $-1$ significa que toma el m√°ximo valor que en este caso es 6 que ser√°n las filas, y $1$, que ser√° el n√∫mero total de columnas. Ahora el array es de $6 \times 1$.
    \end{itemize}
\end{itemize}

\hrule

\section*{\centering \Large \textbf{Datos}}
\label{sec:datos}
\textit{Todos los datos fueron almacenados dentro de la carpeta datos}.
\begin{verbatim}
üì¶ Proyecto-algebra-linea
‚î£ üìÇ datos > datos encriptados.txt
‚îÉ ‚î£ valores desencriptados.txt
‚îÉ ‚î£ valores rotados.txt
‚îÉ ‚î£ valores trasladados.txt
\end{verbatim}

\hrule

\section*{\centering \Large \textbf{Ecuaciones}}
\label{sec:ecuaciones}
Antes de empezar a desencriptar los datos, tenemos que tener todos los datos de nuestra matriz $6 \times 6$ la cual usaremos para resolver el proyecto. 

Tenemos la siguiente matriz la cual tiene inc√≥gnitas que hay que encontrar:
$$
A = 
\begin{pmatrix}
a & 3 & b & 5 & c & 8 \\
6 & d & 0 & e & 7 & f \\
g & 8 & h & 1 & i & 7 \\
11 & j & 8 & k & 12 & m \\
n & -1 & p & -5 & r & 3 \\
4 & t & 2 & w & 9 & z
\end{pmatrix}
$$

\subsection*{\centering \textbf{Primera Ecuaci√≥n}}
\label{sub:ecuacion1}
Resolvemos nuestra ecuaci√≥n de $10 \times 10$
$$
\begin{aligned}
6a + 7b - c - 12d + 14e + 5f - 12g - 3h + 9i - 5j &= 48 \\
2a - 15b + 8c + 6d - 7e + 9f - 9g + 5h - 8i - 6j &= 64 \\
-25a + 10b - 9d - 12e + 14f - 6g + 8h - 13i + 4j &= -132 \\
6a - 3b + 5c - 16d + e + 9f - 7g + 3h - 4i + 5j &= -75 \\
8a - 9b + 6c - d - e - 5f + 7g + 3i + 2j &= -16 \\
-5a + 6b + 9c - 2d + 10e - 14f + 3g + 5h - 12i + 6j &= -408 \\
-4a + 5b + 8c - 2d + 9e - 8f + 4g + h - 2j &= -203 \\
a + b + 2c - 3d + 4e - f - 4g - 7h + 2i - 4j &= 59 \\
10a + 5b - 9c + 6d + e + f + 7g - 8h + 3i + 11j &= 126 \\
-2a + 4b + 3c + 5d - 10e - f + 3g - h - 7i + j &= 2
\end{aligned}
$$
\textbf{C√≥digo para resolver:}
\begin{lstlisting}[language=python]
# Pasamos todos los datos del primer t√©rmino a un array.
primer_termino = np.array([
    [6, 7, -1, -12, 14, 5, -12, -3, 9, -5],
    [2, -15, 8, 6, -7, 9, -9, 5, -8, -6],
    [-25, 10, 0, -9, -12, 14, -6, 8, -13, 4],
    [6, -3, 5, -16, 1, 9, -7, 3, -4, 5],
    [8, -9, 6, -1, -1, -5, 7, 0, 3, 2,],
    [-5, 6, 9, -2, 10, -14, 3, 5, -12, 6],
    [-4, 5, 8, -2, 9, -8, 4, 1, 0, -2],
    [1, 1, 2, -3, 4, -1, -4, -7, 2, -4],
    [10, 5, -9, 6, 1, 1, 7, -8, 3, 11],
    [-2, 4, 3, 5, -10, -1, 3, -1, -7, 1]
], dtype=int)

# Ahora pasamos los datos del segundo t√©rmino a otro array.
segundo_termino = np.array([48, 64, -132, -75, -16, -408, -203, 59, 126, 2], dtype=int)

# Tenemos una clase Ecuacion() la cual hace uso de np.linalg.solve para resolver el sistema.
ecuacion = Ecuacion()

matriz = ecuacion.resolver(primer_termino, segundo_termino)

# la matriz da los resultados tales que.
# (2,‚àí2,‚àí3,5,‚àí9,4,‚àí7,‚àí10,11,0)
\end{lstlisting}
\textbf{Nota:} La clase Ecuacion() se ver√° m√°s adelante.

\medskip
\textbf{Inc√≥gnitas adicionales:} Para las inc√≥gnitas $k, m, n, p, r, t, w, z$ debe resolver las siguientes operaciones entre vectores:

\subsection*{\centering \textbf{Segunda Ecuaci√≥n}}
\label{sub:ecuacion2}
Se tienen los vectores $\vec{U} = (3, 6, 7)$ y $\vec{V} = (k, m, n)$. El resultado de operar $2\vec{U} \times 3\vec{V}$ es igual a $612\hat{i}+ 156\hat{j}- 396\hat{k}$ y el producto $\vec{U} \cdot \vec{V} = 58$.
$$
2\vec{U} \times 3\vec{V} = (612, 156, -396)
$$
Dividiendo por 6:
$$
\frac{2\vec{U} \times 3\vec{V}}{6} = (102, 26, -66)
$$
Sistema de ecuaciones del producto cruz:
$$
\begin{aligned}
6n - 7m &= 102 \\
7k - 3n &= 26 \\
3m - 6k &= -66
\end{aligned}
$$
Despejando $k$ y $m$ en t√©rminos de $n$:
$$
m = \frac{6n - 102}{7} \quad \text{y} \quad k = \frac{3n + 26}{7}
$$
Usando el producto escalar $\vec{U} \cdot \vec{V} = 58$:
$$
3k + 6m + 7n = 58
$$
Sustituyendo $k$ y $m$:
$$
3 \left(\frac{3n + 26}{7}\right) + 6\left(\frac{6n - 102}{7}\right) + 7n = 58
$$
Multiplicando por 7:
$$
3(3n + 26) + 6(6n - 102) + 49n = 406
$$
$$
9n + 78 + 36n - 612 + 49n = 406
$$
$$
94n = 406 - 78 + 612 \Rightarrow 94n = 940 \Rightarrow n = 10
$$
Con $n=10$:
$$
m = \frac{6(10) - 102}{7} = \frac{60 - 102}{7} = \frac{-42}{7} \Rightarrow m = -6
$$
$$
k = \frac{3(10) + 26}{7} = \frac{30 + 26}{7} = \frac{56}{7} \Rightarrow k = 8
$$
\textbf{Resultado:}
$$
k = 8, \quad m = -6, \quad n = 10
$$

\subsection*{\centering \textbf{Tercera Ecuaci√≥n}}
\label{sub:ecuacion3}
Se tienen los vectores $\vec{U} = (6, p, r)$ y $\vec{V} = (t, 8, 9)$. El resultado de operar $3\vec{U} - 10\vec{V}$ es igual a $-42\hat{i}- 68\hat{j}- 126\hat{k}$.
$$
3\vec{U} - 10\vec{V} = (3(6) - 10t, 3p - 10(8), 3r - 10(9)) = (-42, -68, -126)
$$
\textbf{Componente $i$ ($t$):}
$$
18 - 10t = -42 \Rightarrow -10t = -60 \Rightarrow t = 6
$$
\textbf{Componente $j$ ($p$):}
$$
3p - 80 = -68 \Rightarrow 3p = 12 \Rightarrow p = 4
$$
\textbf{Componente $k$ ($r$):}
$$
3r - 90 = -126 \Rightarrow 3r = -36 \Rightarrow r = -12
$$
\textbf{Resultado:}
$$
t = 6, \quad p = 4, \quad r = -12
$$

\subsection*{\centering \textbf{Cuarta Ecuaci√≥n}}
\label{sub:ecuacion4}
Se tienen los vectores:
$$
\vec{U} = \left(\frac{-1}{2}, \frac{\sqrt{38}}{2}, \frac{5}{2}\right) \quad \text{y} \quad \vec{V} = (11, \sqrt{342}, -21)
$$
La magnitud de $|\vec{U}|$ es igual a $-w$. Adem√°s, el producto escalar $\vec{U} \cdot \vec{V}$ es igual a $z$.
\medskip
\textbf{C√°lculo de $w$ (magnitud):}
$$
|\vec{U}| = \sqrt{\left(\frac{-1}{2}\right)^2 + \left(\frac{\sqrt{38}}{2}\right)^2 + \left(\frac{5}{2}\right)^2} = \sqrt{\frac{1}{4} + \frac{38}{4} + \frac{25}{4}} = \sqrt{\frac{64}{4}} = \sqrt{16} = 4
$$
Dado que $|\vec{U}| = -w$:
$$
4 = -w \Rightarrow w = -4
$$
\textbf{C√°lculo de $z$ (producto escalar):}
$$
\vec{U} \cdot \vec{V} = z
$$
Notemos que $\sqrt{342} = \sqrt{9 \times 38} = 3\sqrt{38}$.
$$
z = \left(\frac{-1}{2}\right)(11) + \left(\frac{\sqrt{38}}{2}\right)\left(3\sqrt{38}\right) + \left(\frac{5}{2}\right)(-21)
$$
$$
z = \frac{-11}{2} + \frac{3(\sqrt{38})^2}{2} + \frac{-105}{2} = \frac{-11}{2} + \frac{3(38)}{2} + \frac{-105}{2}
$$
$$
z = \frac{-11 + 114 - 105}{2} = \frac{-2}{2} = -1
$$
\textbf{Resultado:}
$$
w = -4, \quad z = -1
$$

\subsection*{\centering \textbf{Resultado de las ecuaciones.}}
\label{sub:resultado}
\textbf{Variables Encontradas:}
$$
a = 2, \quad b = -2, \quad c = -3, \quad d = 5, \quad e = -9, \quad f = 4, \quad g = -7, \quad h = -10, \quad i = 11, \quad j = 0, \quad k = 8, \quad m = -6, \quad n = 10, \quad w = -4, \quad z = -1, \quad p = 4, \quad t = 6, \quad r = -12
$$
\textbf{Matriz para codificar los vectores:}
$$
\begin{pmatrix}
2 & 3 & -2 & 5 & -3 & 8 \\
6 & 5 & 0 & -9 & 7 & 4 \\
-7 & 8 & -10 & 1 & 11 & 7 \\
11 & 0 & 8 & 8 & 12 & -6 \\
10 & -1 & 4 & -5 & -12 & 3 \\
4 & 6 & 2 & -4 & 9 & -1
\end{pmatrix}
$$

\hrule

\section*{\centering \Large \textbf{Clases}}
\label{sec:clases}
\textit{Ahora que ya resolvimos nuestras ecuaciones y obtuvimos nuestra matriz completa, ya podemos comenzar a programar para poder desencriptar nuestros datos.}

\subsection*{\centering \textbf{Librer√≠as}}
\label{sub:librerias}
\textit{Primero importamos las librer√≠as que usaremos a lo largo de nuestro proyecto.}
\begin{lstlisting}[language=python]
import numpy as np
import matplotlib.pyplot as plt
\end{lstlisting}

\subsection*{\centering \textbf{Cifrado()}}
\label{sub:cifrado}
\textit{Creamos nuestra clase \textbf{Cifrado} la cual Cifra, descifra datos y podemos obtener una matriz inversa para depurar.}

\subsubsection*{\centering Funcionamiento de la clase Cifrado()}
\begin{itemize}
    \item La funci√≥n \textbf{\texttt{inversa()}} devuelve la inversa de la matriz ingresada (usando \texttt{np.linalg.inv()}).
    \item La funci√≥n \textbf{\texttt{cifrar()}} obtiene 2 matrices y las multiplica (usando \texttt{@}) devolviendo la matriz cifrada.
    \item La funci√≥n \textbf{\texttt{descifrar()}} calcula la inversa de la matriz de codificaci√≥n y la multiplica por la matriz cifrada para devolver la matriz descifrada.
\end{itemize}
\begin{lstlisting}[language=python]
class Cifrado():

    def inversa(self, matriz_codificar):
        self.matriz_codificar = matriz_codificar
        matriz_inversa = np.linalg.inv(self.matriz_codificar)
        return matriz_inversa

    def cifrar(self, matriz, matriz_codificar):
        self.matriz = matriz
        self.matriz_codificar = matriz_codificar
        matriz_cifrada = self.matriz_codificar @ self.matriz
        return matriz_cifrada

    def descifrar(self, matriz_codificacion, matriz_resolver):
        self.matriz_codificacion = matriz_codificacion
        self.matriz_resolver = matriz_resolver
        matriz_inversa = np.linalg.inv(self.matriz_codificacion)
        matriz_decifrada = matriz_inversa @ self.matriz_resolver
        return matriz_decifrada
\end{lstlisting}

\subsection*{\centering \textbf{Crear\_Array()}}
\label{sub:crear-array}
\textit{La clase \texttt{crear\_array()} fue creada con el objetivo de obtener un arreglo con valores alternados de $(x,y)$ en un formato ($x_1, y_1, x_2, y_2\dots$) y los separar√° en dos arreglos independientes con las coordenadas $(x)$ y $(y)$.}

\subsubsection*{\centering Funcionamiento de la clase Crear\_Array()}
\begin{itemize}
    \item \textbf{M√©todo \texttt{valores\_x()}}: Recorre el arreglo original y toma los valores impares (√≠ndice 1, 3, 5...).
    \item \textbf{M√©todo \texttt{valores\_y()}}: Recorre el arreglo original y toma los valores pares (√≠ndice 2, 4, 6...).
\end{itemize}
\begin{lstlisting}[language=python]
class crear_array():

    def valores_x(self, array):
        self.array = array
        puntos_x = []
        contador = 1
        for x in self.array:
            if contador % 2 != 0:
                puntos_x.append(x)
            contador += 1
        return puntos_x

    def valores_y(self, array):
        self.array = array
        puntos_y = []
        contador = 1
        for y in self.array:
            if contador % 2 == 0:
                puntos_y.append(y)
            contador +=1
        return puntos_y
\end{lstlisting}

\subsection*{\centering \textbf{Ecuacion()}}
\label{sub:ecuacion}
\textit{Creamos una clase llamada \texttt{Ecuacion} con la finalidad de resolver la ecuaci√≥n $10 \times 10$ brindada en las instrucciones del proyecto.}

\subsubsection*{\centering Funcionamiento de la clase Ecuacion()}
\begin{itemize}
    \item Recibe el primer y segundo t√©rmino separados.
    \item Usa \texttt{np.linalg.solve()} para encontrar los valores de las inc√≥gnitas.
\end{itemize}
\begin{lstlisting}[language=python]
class Ecuacion():
    def resolver(self, primer_termino, segundo_termino):
        self.primer_termino = np.array(primer_termino)
        self.segundo_termino = np.array(segundo_termino)
        solucion = np.linalg.solve(self.primer_termino, self.segundo_termino)
        return solucion
\end{lstlisting}

\subsection*{\centering \textbf{Desempaquetar\_Array()}}
\label{sub:desempaquetar-array}
\textit{Esta clase transforma los arreglos de coordenadas anidados en listas unidimensionales.}
\begin{lstlisting}[language=python]
class Desempaquetar_Array():
    def desempaquetar(self, valores_x, valores_y):
        self.valores_x = valores_x
        self.valores_y = valores_y
        new_values_x = []
        new_values_y = []

        for nueva_lista in self.valores_x:
            for x in np.ravel(nueva_lista):
                new_values_x.append(x)

        for nueva_lista in self.valores_y:
            for y in np.ravel(nueva_lista):
                new_values_y.append(y)

        return new_values_x, new_values_y
\end{lstlisting}

\subsection*{\centering \textbf{Rotacion()}}
\label{sub:rotacion}
\textit{La clase \texttt{Rotacion} aplica una transformaci√≥n geom√©trica de rotaci√≥n a un conjunto de puntos en el plano cartesiano.}

\subsubsection*{\centering Matriz de Rotaci√≥n}
La matriz de rotaci√≥n en 2D est√° definida como:
$$
R(\theta) =
\begin{pmatrix}
\cos(\theta) & -\sin(\theta) \\
\sin(\theta) & \cos(\theta)
\end{pmatrix}
$$
Y la transformaci√≥n de un punto $(x, y)$ se obtiene mediante:
$$
\begin{pmatrix}
x' \\
y'
\end{pmatrix}
=
R(\theta)
\cdot
\begin{pmatrix}
x \\
y
\end{pmatrix}
$$
\subsubsection*{\centering Funcionamiento de la clase Rotacion()}
\begin{lstlisting}[language=python]
class Rotacion():
    def rotar_matriz(self, valores_x, valores_y):
        self.valores_x = valores_x
        self.valores_y = valores_y
        angulo = 135
        angulo_rad = np.deg2rad(angulo)

        rotacion_x = []
        rotacion_y = []

        matriz_rotacion = np.array([
            [np.cos(angulo_rad), -np.sin(angulo_rad)],
            [np.sin(angulo_rad), np.cos(angulo_rad)]
        ])

        for x, y in zip(self.valores_x, self.valores_y):
            new_array = np.array([x, y]).reshape(2,1)
            array_rotado = matriz_rotacion @ new_array
            rotacion_x.append(array_rotado[0,0])
            rotacion_y.append(array_rotado[1,0])

        return rotacion_x, rotacion_y
\end{lstlisting}

\subsection*{\centering \textbf{Traslacion()}}
\label{sub:traslacion}
\textit{La clase \texttt{Traslacion} aplica una transformaci√≥n geom√©trica de traslaci√≥n a un conjunto de puntos en el plano cartesiano.}

\subsubsection*{\centering Matriz de Traslaci√≥n (Coordenadas Homog√©neas)}
$$
T(a, b) =
\begin{pmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1
\end{pmatrix}
$$
$$
\begin{pmatrix}
x' \\
y' \\
1
\end{pmatrix}
=
T(a, b)
\cdot
\begin{pmatrix}
x \\
y \\
1
\end{pmatrix}
$$
\subsubsection*{\centering Funcionamiento de la clase Traslacion()}
\begin{lstlisting}[language=python]
class Traslacion():
    def trasladar_matriz(self, x, y, a, b):
        self.x = x
        self.y = y
        # a = movimiento en x
        self.a = a
        # b = mobimiento en y
        self.b = b

        valores_x = []
        valores_y = []

        matriz_traslacion = np.array([
            [1, 0, self.a],
            [0, 1, self.b],
            [0, 0, 1]
        ])

        for punto_x, punto_y in zip(self.x, self.y):
            punto = np.array([punto_x, punto_y, 1]).reshape(3,1)
            resultado = matriz_traslacion @ punto
            valores_x.append(resultado[0,0])
            valores_y.append(resultado[1,0])

        return valores_x, valores_y
\end{lstlisting}

\subsection*{\centering \textbf{GuardarDatos()}}
\label{sub:guardar-datos}
\textit{Esta clase permite almacenar las coordenadas generadas en un archivo de texto externo en formato de pares ordenados.}

\subsubsection*{\centering Funcionamiento de la clase GuardarDatos()}
\begin{lstlisting}[language=python]
class GuardarDatos():
    def save(self, valores_x, valores_y, nombre_archivo):
        self.valores_x = valores_x
        self.valores_y = valores_y
        self.nombre_archivo = nombre_archivo

        with open(self.nombre_archivo, "w") as f:
            for x, y in zip(valores_x, valores_y):
                f.write(f"({x}, {y})\n")
\end{lstlisting}

\subsection*{\centering \textbf{App()}}
\label{sub:app}
\textit{La clase \texttt{App} se encarga de abrir un archivo de datos, convertirlos en una matriz columna y aplicar el m√©todo de cifrado o descifrado.}

\subsubsection*{\centering Funcionamiento de la clase App()}
\begin{lstlisting}[language=python]
class App():
    def abrir_document(self, matriz, archivo, condicional):
        self.archivo = archivo
        self.matriz = matriz
        self.condicional = condicional

        array = []
        array_valores_x = []
        array_valores_y = []
        resultado = []
        matriz_original = np.array(self.matriz)

        with open(self.archivo, "r") as f:
            for line in f:
                valores_Array = [float(x) for x in line.strip().split()]
                array = np.array(valores_Array).reshape(-1, 1)

                cir = Cifrado()
                create = crear_array()

                if self.condicional == "cifrar":
                    resultado = cir.cifrar(array, matriz_original)
                elif self.condicional == "descifrar":
                    resultado = cir.descifrar(matriz_original, array)

                valores_x = create.valores_x(resultado)
                valores_y = create.valores_y(resultado)

                array_valores_x.append(valores_x)
                array_valores_y.append(valores_y)

        return array_valores_x, array_valores_y
\end{lstlisting}

\subsection*{\centering \textbf{Graficar()}}
\label{sub:graficar}
\textit{Esta clase nos permite graficar todos los puntos $(x, y)$ con los datos Desencriptados, Rotados y Trasladados.}

\subsubsection*{\centering Funcionamiento de la clase Graficar()}
\begin{lstlisting}[language=python]
class Graficar():
    def graficadora(self, x, y):
        self.x = x
        self.y = y

        plt.scatter(self.x, self.y, color='blue', marker='o', label='Puntos (x, y)')
        # Personalizar el gr√°fico
        plt.title("Gr√°fico de puntos")
        plt.xlabel("Eje X")
        plt.ylabel("Eje Y")
        plt.legend()
        plt.grid(True)

        # Mostrar el gr√°fico
        plt.show()
\end{lstlisting}

\hrule

\section*{\centering \Large \textbf{Instancias}}
\label{sec:instancias}
\textit{Inicializamos nuestras instancias de clases:}
\begin{lstlisting}[language=python]
    aplicacion = App()
    rotar = Rotacion()
    desempaquetador = Desempaquetar_Array()
    graficar = Graficar()
    traslacion = Traslacion()
    guardar_datos = GuardarDatos()
    cir = Cifrado()
    create = crear_array()
\end{lstlisting}

\hrule

\section*{\centering \textbf{Comprobaci√≥n de Datos}}
\addcontentsline{toc}{section}{Comprobaci√≥n de Datos}
\hrule

\subsection*{Matriz Inversa}
Buscamos comprobar que la clase \texttt{Cifrado} con el m√©todo \texttt{inversa} funciona para poder obtener la inversa de nuestra matriz.

\subsubsection*{Input:}
\begin{lstlisting}[style=bashstyle]
inversa = cir.inversa(matriz_codificacion)
print(f"La matriz inversa es: \n{inversa}")
\end{lstlisting}

\subsubsection*{Output:}
\begin{lstlisting}[style=bashstyle]
La matriz inversa es: 
[[-0.13562749 -0.03955583  0.16534674  0.097423    0.19435366 -0.08729311]
 [ 0.02119736 -0.18428661  0.04575739 -0.04399749  0.08185104  0.26227216]
 [ 0.28413995  0.12090928 -0.33697884 -0.11187932 -0.30448355  0.15573015]
 [ 0.03036874 -0.074251    0.03071444  0.03456945  0.01842657  0.00880997]
 [ 0.01988791  0.10211607 -0.03490467  0.02074167 -0.08727739 -0.06304735]
 [ 0.21047035  0.19392416 -0.17502619 -0.04965431 -0.19964907 -0.06674523]]
\end{lstlisting}

\hrule

\subsection*{Desencriptar datos}
Multiplicaremos nuestra matriz inversa por la matriz con los datos codificados y de esta manera poder descifrarlos. 
La matriz con los datos encriptados es:
\begin{lstlisting}[style=bashstyle]
[230.3]
[263.5]
[238.8]
[814.8]
[-100]
[432.7]
\end{lstlisting}

\subsubsection*{Input:}
\begin{lstlisting}[style=pythonstyle]
#nuestra matriz de 6x1 y nuestra matriz de 6x6, usamos reshape para cambiar su dimensi√≥n a 6x1
dato_encriptado = np.array([230.3, 263.5, 238.8, 814.8, -100, 432.7]).reshape(-1, 1)
#guardamos los datos usando la clase decifrar.
datos_desencriptados = cir.descifrar(matriz_codificacion, dato_encriptado)
#mostramos los datos por pantalla
print(datos_desencriptados)
\end{lstlisting}

\subsubsection*{Output:}
\begin{lstlisting}[style=bashstyle]
[[20. ]
 [36.7]
 [23.5]
 [24.9]
 [21.5]
 [ 8.4]]
\end{lstlisting}

\hrule

\subsection*{Rotaci√≥n de datos}
A continuaci√≥n, comprobaremos la **rotaci√≥n de los datos** utilizando la clase \texttt{Rotacion()}.

La clase \texttt{Rotacion()} requiere \texttt{datos\_x} y \texttt{datos\_y}. Para obtener estos valores a partir de \texttt{datos\_desencriptados}, usamos la clase \texttt{crear\_array()}.

\subsubsection*{Input: Obtenci√≥n de $x$ e $y$}
\begin{lstlisting}[style=pythonstyle]
#Primero obtenemos los resultados (x, y), as√≠ se los podemos pasar a nuestra clase.
valor_prueba_x = create.valores_x(datos_desencriptados)
print(f"Los valores de x son : {valor_prueba_x}")
valor_prueba_y = create.valores_y(datos_desencriptados)
print(f"Los valores de y son: {valor_prueba_y}")
#estos datos a√∫n no est√°n rotados, la rotaci√≥n ser√° ahora con la clase Rotacion()
\end{lstlisting}

\subsubsection*{Output:}
\begin{lstlisting}[style=bashstyle]
Los valores de x son : [array([20.]), array([23.5]), array([21.5])]
Los valores de y son: [array([36.7]), array([24.9]), array([8.4])]
\end{lstlisting}

\textbf{\textcolor{red}{Nota:}} Podemos notar que los valores de $(x,y)$ est√°n en arrays anidados. Es necesario desempaquetarlos a trav√©s de la clase \texttt{Desempaquetar\_Array()} antes de la rotaci√≥n.

\subsubsection*{Input: Desempaquetado y Rotaci√≥n}
\begin{lstlisting}[style=pythonstyle]
valor_prueba_desempaquetar_x, valor_prueba_desempaquetar_y = desempaquetador.desempaquetar(valor_prueba_x, valor_prueba_y)
print(f"Los valores de x desempaquetados: {valor_prueba_desempaquetar_x}")
print(f"Los valores de y desempaquetados: {valor_prueba_desempaquetar_y}")

#Rotaci√≥n de datos
valor_prueba_rotados_x, valor_prueba_rotados_y = rotar.rotar_matriz(valor_prueba_desempaquetar_x, valor_prueba_desempaquetar_y)
print(f"Los valores x rotados son: {valor_prueba_rotados_x}")
print(f"Los valores y rotados son: {valor_prueba_rotados_y}")
\end{lstlisting}

\subsubsection*{Output:}
\begin{lstlisting}[style=bashstyle]
Los valores de x desempaquetados: [np.float64(20.000000000000007), np.float64(23.499999999999986), np.float64(21.50000000000001)]
Los valores de y desempaquetados: [np.float64(36.69999999999996), np.float64(24.900000000000002), np.float64(8.400000000000023)]
Los valores x rotados son: [np.float64(-40.09295449327722), np.float64(-34.22396820942889), np.float64(-21.142492757477793)]
Los valores y rotados son: [np.float64(-11.808683245815308), np.float64(-0.9899494936611762), np.float64(9.263098833543765)]
\end{lstlisting}

Con los valores rotados exitosamente, pasaremos a comprobar la **traslaci√≥n**.

\hrule

\subsection*{Traslaci√≥n}
Ahora comprobaremos que la clase \texttt{Traslacion()} funciona pas√°ndole los datos anteriormente rotados.

La clase \texttt{Traslacion()} recibe los datos de $(x,y)$ y $(a,b)$. Donde $(a,b)$ son las distancias de traslaci√≥n para los ejes $(x,y)$.

\subsubsection*{Input:}
\begin{lstlisting}[style=pythonstyle]
#usaremos los datos anteriomente rotados para obtener los datos finales.
valor_prueba_transladado_x, valor_prueba_trasladado_y = traslacion.trasladar_matriz(valor_prueba_rotados_x, valor_prueba_rotados_y, 20, 30)

#pasamos los valores (a,b) como (20,30)
#mostramos los datos.

print(f"Los valores trasladados para x son: {valor_prueba_transladado_x}")
print(f"Los valores trasladados para y son: {valor_prueba_trasladado_y}")
\end{lstlisting}

\subsubsection*{Output:}
\begin{lstlisting}[style=bashstyle]
Los valores trasladados para x son: [np.float64(-20.09295449327722), np.float64(-14.22396820942889), np.float64(-1.1424927574777932)]
Los valores trasladados para y son: [np.float64(18.19131675418469), np.float64(29.010050506338825), np.float64(39.263098833543765)]
\end{lstlisting}

Finalizada la traslaci√≥n, procedemos a utilizar el m√©todo de automatizaci√≥n para **desencriptar el archivo** \texttt{datos encriptados.txt}. Mostraremos las gr√°ficas para corroborar los resultados.

\hrule

\section*{\centering \textbf{Gr√°ficas de Comprobaci√≥n}}
\addcontentsline{toc}{section}{Gr√°ficas de Comprobaci√≥n}
\hrule

\subsubsection*{Datos Desencriptados (Test)}
\begin{lstlisting}[style=pythonstyle]
#Grafica para los puntos desencriptados √∫nicamente.
graficar.graficadora(valor_prueba_x, valor_prueba_y)
\end{lstlisting}
\begin{figure}[h]
¬† ¬† \centering
¬† ¬† \includegraphics[width=0.7\textwidth]{../imagenes/datos_desencriptados_test.png}
¬† ¬† \caption{Gr√°fica de Puntos Desencriptados (Test)}
\end{figure}

\subsubsection*{Datos Rotados (Test)}
\begin{lstlisting}[style=pythonstyle]
#Grafica para los datos rotados
graficar.graficadora(valor_prueba_rotados_x, valor_prueba_rotados_y)
\end{lstlisting}
\begin{figure}[h]
¬† ¬† \centering
¬† ¬† \includegraphics[width=0.7\textwidth]{../imagenes/datos_rotados_test.png}
¬† ¬† \caption{Gr√°fica de Puntos Rotados (Test)}
\end{figure}

\subsubsection*{Datos Trasladados (Test)}
\begin{lstlisting}[style=pythonstyle]
#Gr√°fica para los datos rotados y trasladados
graficar.graficadora(valor_prueba_transladado_x, valor_prueba_trasladado_y)
\end{lstlisting}
\begin{figure}[h]
¬† ¬† \centering
¬† ¬† \includegraphics[width=0.7\textwidth]{../imagenes/datos_trasladados_test.png}
¬† ¬† \caption{Gr√°fica de Puntos Rotados y Trasladados (Test)}
\end{figure}

\FloatBarrier % Barrera para asegurar que las figuras se queden antes del nuevo t√≠tulo

\hrule

\section*{\centering \textbf{Desencriptar Archivo}} 
\addcontentsline{toc}{section}{Desencriptar Archivo}
\hrule

El siguiente paso es procesar el archivo \texttt{datos encriptados.txt}, el cual contiene los datos encriptados. Cada l√≠nea tiene 6 datos que se resuelven l√≠nea por l√≠nea usando matrices $6 \times 1$.

\subsection*{Obtenci√≥n y Transformaci√≥n de Datos}
\begin{lstlisting}[style=pythonstyle]
#Desencriptamos todos los valores para (x, y)
valores_x, valores_y = aplicacion.abrir_document(matriz_codificacion, "/content/drive/MyDrive/Colab Notebooks/datos encriptados.txt", "decifrar")

#Los datos est√°n anidados, as√≠ que los aplanamos con la clase Desempaquetar_Array()
desempaquetar_x, desempaquetar_y = desempaquetador.desempaquetar(valores_x, valores_y)

#Rotamos los datos ahora que est√°n desempaquetados
valores_rotados_x, valores_rotados_y = rotar.rotar_matriz(desempaquetar_x, desempaquetar_y)

#Trasladamos los datos ya rotados para obtener la √∫ltima gr√°fica.
valores_trasladados_x, valores_trasladados_y = traslacion.trasladar_matriz(valores_rotados_x, valores_rotados_y, 20, 30)
\end{lstlisting}

Con todos los valores \textbf{Desencriptados}, \textbf{Rotados} y \textbf{Trasladados}, utilizamos la clase \texttt{Graficar()} para visualizar los datos.

\hrule

\section*{\centering \textbf{Gr√°ficas - Datos Resueltos}}
\addcontentsline{toc}{section}{Gr√°ficas - Datos Resueltos}
\hrule

\subsection*{Gr√°fico Desencriptado}
\begin{lstlisting}[style=pythonstyle]
graficar.graficadora(desempaquetar_x, desempaquetar_y)
\end{lstlisting}
\begin{figure}[h]
¬† ¬† \centering
¬† ¬† \includegraphics[width=0.7\textwidth]{../imagenes/datos_desencriptados.png}
¬† ¬† \caption{Gr√°fico de los Datos Desencriptados Finales}
\end{figure}

\subsection*{Gr√°fico Matriz Rotaci√≥n}
\begin{lstlisting}[style=pythonstyle]
graficar.graficadora(valores_rotados_x, valores_rotados_y)
\end{lstlisting}
\begin{figure}[h]
¬† ¬† \centering
¬† ¬† \includegraphics[width=0.7\textwidth]{../imagenes/datos_rotados.png}
¬† ¬† \caption{Gr√°fico de los Datos Rotados}
\end{figure}

\subsection*{Gr√°fico Matriz Rotaci√≥n y Traslado}
\begin{lstlisting}[style=pythonstyle]
graficar.graficadora(valores_trasladados_x, valores_trasladados_y)
\end{lstlisting}
\begin{figure}[h]
¬† ¬† \centering
¬† ¬† \includegraphics[width=0.7\textwidth]{../imagenes/datos_trasladados.png}
¬† ¬† \caption{Gr√°fico de los Datos Rotados y Trasladados}
\end{figure}

\FloatBarrier % Barrera para asegurar que las figuras se queden antes del nuevo t√≠tulo

\hrule

\section*{\centering \textbf{Guardar Datos}}
\addcontentsline{toc}{section}{Guardar Datos}
\hrule

Guardamos los datos ya desencriptados, rotados y trasladados en nuevos archivos.

\begin{lstlisting}[style=pythonstyle]
guardar_datos.save(desempaquetar_x, desempaquetar_y, "datos\valores desencriptados.txt")
guardar_datos.save(valores_rotados_x, valores_rotados_y, "datos\valores rotados.txt")
guardar_datos.save(valores_trasladados_x,valores_trasladados_y,"datos\valores trasladados.txt")
\end{lstlisting}

\vspace{0.5cm}

\textit{Para ver los datos \textbf{desencriptados} presione} \href{https://github.com/jgarnigar/Proyecto-Algebra-Lineal/blob/master/datos/valores%20desencriptados.txt}{\textit{aqu√≠}}

\textit{Para ver los datos \textbf{rotados} presione} \href{https://github.com/jgarnigar/Proyecto-Algebra-Lineal/blob/master/datos/valores%20rotados.txt}{\textit{aqu√≠}}

\textit{Para ver los datos \textbf{trasladados} presione} \href{https://github.com/jgarnigar/Proyecto-Algebra-Lineal/blob/master/datos/valores%20trasladados.txt}{\textit{aqu√≠}}

\vspace{0.5cm}

\hrule

\section*{\centering \textbf{Conclusiones y Trabajo Futuro}}
\addcontentsline{toc}{section}{Conclusiones y Trabajo Futuro}
\hrule

El presente proyecto ha culminado con la **implementaci√≥n y validaci√≥n exitosa** de un sistema de descifrado y transformaci√≥n de datos fundamentado en los principios del √Ålgebra Lineal. Mediante la correcta aplicaci√≥n de la inversi√≥n de matrices y operaciones de multiplicaci√≥n, se ha logrado **descifrar la totalidad de los datos** contenidos en el archivo fuente, confirmando la precisi√≥n de la clase \texttt{Cifrado()}.

Adicionalmente, se demostr√≥ la funcionalidad de las transformaciones geom√©tricas. Las clases \texttt{Rotacion()} y \texttt{Traslacion()} ejecutaron las manipulaciones vectoriales deseadas, lo cual fue corroborado por las gr√°ficas finales. La **integraci√≥n** de todas las clases (descifrado, desempaquetado y transformaciones) permiti√≥ procesar el archivo de datos de forma **automatizada y eficiente**, cumpliendo a cabalidad con el objetivo principal del proyecto.

\subsection*{Trabajo Futuro}

Para expandir el alcance de este trabajo, se proponen las siguientes l√≠neas de mejora:
\begin{itemize}
    \item Implementar un algoritmo de cifrado m√°s robusto que utilice m√©todos de √Ålgebra Lineal distintos al cifrado Hill b√°sico.
    \item Optimizar el manejo de la memoria con \texttt{NumPy} para procesar archivos de datos de mayor volumen de manera m√°s eficiente.
\end{itemize}

\hrule

\hrule
\section*{\centering \textbf{Autor y Contacto}}
\addcontentsline{toc}{section}{Autor y Contacto}

\begin{center}
    % Parte 1: Identificaci√≥n y Credenciales
    \vspace{0.3cm}
    \textbf{Junior Eduardo Garniga Rojas} \\
    \textit{Estudiante de La Universidad Mariano G√°lvez de Guatemala} \\
    
    % Parte 2: Contacto Digital
    \vspace{0.5cm}
    \small \text{C√≥digo Fuente disponible en:} \\
    \href{https://github.com/jgarnigar}{\texttt{jgarnigar}}
\end{center}
\hrule

\clearpage

\section*{Anexo A: Estructura Completa}
\addcontentsline{toc}{section}{Estructura Completa}
% Usamos un entorno de listado o c√≥digo para simular la estructura de directorios
\begin{verbatim}
Proyecto-algebra-linea
‚îú‚îÄ datos/
‚îÇ  ‚îú‚îÄ valores_trasladados.txt
‚îÇ  ‚îú‚îÄ datos_encriptados.txt
‚îÇ  ‚îú‚îÄ datos.txt
‚îÇ  ‚îú‚îÄ practica.txt
‚îÇ  ‚îú‚îÄ valores_desencriptados.txt
‚îÇ  ‚îî‚îÄ valores_rotados.txt
‚îÇ
‚îú‚îÄ funciones/
‚îÇ  ‚îú‚îÄ __init__.py
‚îÇ  ‚îú‚îÄ app.py
‚îÇ  ‚îú‚îÄ cifrado.py
‚îÇ  ‚îú‚îÄ crear_array.py
‚îÇ  ‚îú‚îÄ desempaquetar.py
‚îÇ  ‚îú‚îÄ ecuacion.py
‚îÇ  ‚îú‚îÄ graficar.py
‚îÇ  ‚îú‚îÄ guardar.py
‚îÇ  ‚îú‚îÄ rotacion.py
‚îÇ  ‚îî‚îÄ traslacion.py
‚îÇ
‚îú‚îÄ imagenes
‚îÇ  ‚îú‚îÄ datos_desencriptados_test.png
‚îÇ  ‚îú‚îÄ datos_desencriptados.png
‚îÇ  ‚îú‚îÄ datos_rotados_test.png
‚îÇ  ‚îú‚îÄ datos_rotados.png
‚îÇ  ‚îú‚îÄ datos_trasladados_test.png
‚îÇ  ‚îî‚îÄ datos_trasladados.png
‚îÇ
‚îú‚îÄ .gitignore
‚îú‚îÄ FICHA_TECNICA.md
‚îú‚îÄ INSTRUCCIONES_PROYECTO.pdf
‚îú‚îÄ PROYECTO_ALGEBRA_LINEAL.pdf
‚îú‚îÄ PROYECTO_ALGEBRA_LINEAL.tex
‚îú‚îÄ README.md
‚îú‚îÄ clases.py
‚îú‚îÄ ecuacion.py
‚îú‚îÄ main.py
‚îî‚îÄ requirements.txt
\end{verbatim}

\hrule
\clearpage


\hrule

\section*{\centering \textbf{Anexo B: Herramientas y Tecnolog√≠as}}
\addcontentsline{toc}{section}{Herramientas y Tecnolog√≠as}
\hrule

\begin{center}
\begin{tabular}{|p{3cm}|p{2cm}|p{8cm}|} % 'p' define ancho de columna
\hline
\textbf{Tecnolog√≠a} & \textbf{Versi√≥n} & \textbf{Funci√≥n en el proyecto} \\
\hline
\textbf{Python} & [V 3.10] & Lenguaje de programaci√≥n principal utilizado para implementar las clases de cifrado, rotaci√≥n y traslaci√≥n. \\
\hline
\textbf{NumPy} & [V 2.1.2] & Fundamental para la manipulaci√≥n y operaci√≥n eficiente de las \textbf{matrices} de $6 \times 6$ y $6 \times 1$ durante el proceso de descifrado. \\
\hline
\textbf{Matplotlib} & [V3.10.3] & Utilizada para la \textbf{visualizaci√≥n de los datos}, generando las gr√°ficas de comprobaci√≥n y los resultados finales (desencriptados, rotados y trasladados). \\
\hline
\end{tabular}
\end{center}

\hrule

\section*{\centering \textbf{Anexo C: Fundamentos Te√≥ricos}}
\addcontentsline{toc}{section}{Anexo C: Fundamentos Te√≥ricos}
\hrule

\subsection*{Matriz}
Una matriz es un conjunto bidimensional de n√∫meros o expresiones dispuesto en filas y columnas. Es la herramienta fundamental utilizada para codificar y descifrar datos en este proyecto. En nuestro caso, se emplea una matriz cuadrada de $6 \times 6$ como clave de codificaci√≥n.

\subsection*{Matriz Inversa}
La matriz inversa, denotada como $A^{-1}$ para una matriz $A$, es crucial para el descifrado. Si $A \cdot X = B$ (donde $X$ es la matriz de datos encriptados y $B$ es la matriz de datos originales), entonces la matriz original se recupera multiplicando la matriz inversa por la matriz encriptada: $A^{-1} \cdot A \cdot X = A^{-1} \cdot B$. Para que una matriz tenga inversa, su determinante debe ser distinto de cero.

\subsection*{Cifrado Hill (Conceptual Simple)}
El Cifrado Hill es un esquema de cifrado por sustituci√≥n polialfab√©tica basado en el √Ålgebra Lineal. Consiste en dividir el mensaje de texto en bloques (vectores) y multiplicarlos por una **matriz clave** (nuestra matriz $6 \times 6$) para obtener el texto cifrado. Para descifrar el mensaje, el texto cifrado se multiplica por la **matriz inversa** de la clave, que es el m√©todo que replicamos en este proyecto.


\end{document}

